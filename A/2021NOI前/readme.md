content:
[toc]

### jzoj7120

0. 一个多项式。次数可以为负，有10^5个位置有值，求分解为 的方案数。i可以为负.
1. **基本观察** :次数全都>=0的分解方式为1，只是拿负数做背包而已；每个最低次一定会被分解出来。
2. **实现发现** : 因式最多60个。
3. **统计** ： 实际上还要再观察一下：背包不为0的项不可能超过n！（因为是乘回去的），因此直接背包即可。
4. 总结：所以这题就是不断发现结论。

### jzoj7121

0. 一个分层图，每层是完全图，层与层间(i,x)与(i+1,x)有边，求从(1,1)出发哈密顿路径数。n<=500, m<=1e9.
1. **设定状态** ： 这个完全图让每一层很混乱，因此**状态很重要**：**考虑让每一层无序！** 即按访问顺序排列，结果我们就轻松地观察出了状态：（1）有一些向上的然后下来；（2）有一些向下，断了；（3）其他直接连向下一个点。所以直接设f(c,j)表示c段，j个向上的。
2. **找转移矩阵** ： 直接n^3 dp.

### jzoj7121.5(树猜) 交互

0. n个点的树，1为根，每次询问S可得到所有点对lca中深度最深那个（每次询问S相同，答案就相同），30000次询问还原树。n<=3000.
1. **使用性质**： 交互题常用的性质：每个点期望深度为log。那么random_shuffle, 再动态维护虚树，加动态链剖（见交互总结），暴力添加lca即可。
2. **使用确定性算法** ： 点分治！其他同上。

### jzoj7122

0. 一颗2e6个点的树，每个点有两个权值：ai,bi,手里拿着ai走到这个点颜色就会变成bi，求x到y的最终颜色，qn<=7e5.
1. **选择算法** ： 选择了倍增；然鹅树上路径问题点分治是利器，下次要选择点分治。
2. **划分问题** ： 分成跳到lca，找下一个点和跳到y三个阶段，发现第2个可以二分+栈（相当于建虚树），第3个可以将颜色的并查集连边解决。
3. **更优解法** ： 实际上部分1不用倍增，可以用类似方法解决，部分3不用查nlog次fa，可以直接不建虚点，维护并查集的根。

### jzoj7123

0. 现有长度为n+1数列A，长度为n数列B，求删掉A一个位置后，匹配个数的期望。n<=1e6,V<998244353.

1. **探究+设定状态** : 怎么知道是不是最优的决策？**假设B确定**，我们就可以直接dp；那么B不确定，就dp套dp！介于每个转移去向确定，因此正确。这可以由n ^ 3->n ^ 2，然鹅并没有看懂题解是怎么搞出On来的。

2. **重新转化** ： 假设跟i匹配为左箭头，i+1为右箭头，那么遇到左箭头+1，右-1，答案就是最大前缀和 + 初始右箭头个数。分开算：第1部分[生成函数推导](https://www.cnblogs.com/jz-597/p/14891981.html), 第二部分组合数。

   值得注意的是1.要把贡献算为>=Ans的，就可以折线； 2.要把Ai=Ai+1的拆开来算。

### jzoj7124

0. 大欺诈。有k种颜色，求把一棵树复制A遍后，$\sum_s \sum_t 把A_{i,s} 与A_{i mod n+1, t} $ 连边后的染色（相邻色不同）的方案数。
1. **转化：** 实际上就是一个基环树，等于环的染色方案数再乘(k-1)^(A*(n-cir)). 
2. 环的染色方案数可以用转移矩阵搞出来，也可以打表发现是$(k-1)^{A*len} + (A * len\& 1?-1:1)*(k-1) $$.不用点分治，树形dp即可。

### jzoj7125

0. 有n件装备，m个装备栏，当前装备栏装了ai,备了bi，同一件装备不能被同时装备两次。每个装备有价值ci<=n,总价值是$\sum c_{ai} * n^i$, 能交换k次，最大化价值。
1. 简单观察：每个点只有一条出边，交换相当于反向，有环一定不行，那么用带权并查集维护链长即可。
2. 然鹅：只剩树形结构:那么维护每个子树内空位的位置即可。

### jzoj7126

0. 有500位选手，每次随机调出相邻两个选手pk，x这位获胜概率为ax / (ax+ay),求每一位选手留到最后的概率。
1. 简单设出dp:f\[l\]\[r\][x] 表示x逐鹿群雄(bushi ，在l~r中胜出；然鹅==int*int没写1ll??这几天好多次没1ll……== 
2. **观察：** 相邻性，等价于左边没消完就不会越过i！因此可以l~r区间中只用dp l或r！那么这个dp就少了一维，进一步可以发现断点位置跟系数无关，即优化到n^3.

### jzoj7127

0. 有20个集合。每个集合有颜色，集合里有 1e5个数(<=1e5),表示这堆石子可能的大小。做nim游戏；还有一种特殊操作：取不多于m个同色石子。求先手获胜方案数。
1. **考虑博弈题流程：** 还是先找出SG函数： **简化条件** 假设同色，石子数都<=m,那么SG值就是$(\sum ai)mod (m+1)$ .在此基础上考虑，发现同色SG值就是$XOR_i\space ai/(m+1)  + (\sum ai)mod (m+1)$ .十分厉害。接下来FWT即可。

### jzoj7128

0. 有n个球，无限个格，填一个红格拿走m个球，蓝格m+1个，白格直接结束。求不同的方案数（颜色不同或拿走的球集合不同都算）
1. 打表+BM，发现了递推式； 实际上根据拿球的个数dp（每种方案对应一种转移），也可以直接发现fn=fn-m + fn-m+1.

### jzoj7129

0. 有个集合S，里头是最大质因子不超过M的所有数。有集合Ai，Ai+1中为phi(x)属于Ai，x属于s的所有数。求1~n的集合大小。
1. phi倒推可能性多，但是**每个数只有一个phi！**（唯一确定性).探究，发现次数就是每次把质数变成phi，一直变成1，能提供的2的次数（个数）。
2. FFT即可。NbDft真快！

### jzoj7130

0. 求有一个内角是180°的，内部和边上不存在其他点的格点四边形个数。
1. 先来一手pick定理。接下来应该直接考虑**三角形的类型**（而不是线段），发现只有一种最重要。
2. 根据同余方程<=m,<n范围内解的唯一性，推导出反演式子。杜教筛。
3. 注意1ll问题，筛法变量问题。

### jzoj7131

0. a,b,c,d ,求C(a,b)与C(c,d)大小关系。随机。1e9
1. 我的解法：求ln，分段打表，由于相差不大，**再差分一次**减小码量。
2. gmh：将整个杨辉三角分块,B=100,落到同一块内概率极小，>1e9/=100即可。
3. LiuShuo: 斯特林公式：v!约等于$e^{-v + vlogv} \sqrt{2\pi v}$
4. PT：对ln积分即可。

### jzoj7132

0. wqs二分的两点问题：1.斜率是否可能为小数？ 2.中间可能有点斜率相同，二分不到。

### jzoj7133

0. 建虚树问题很多，下次要把虚树用到的数组开到build前面，一起清0.前向星可以直接NX[x]. 树状数组没有区间修改。

### jzoj7134

0. 一棵树上有10条多余的边，有q个询问，询问以某个点为起点的最短路之和。n,q<=1e5.
1. **考虑路径是什么样子的** ： ==不应该考虑强联通分量==！应该注意到，一定是由最后的某个特殊点再完全走一段树边得到最短路的。而前面特殊点之前的转移可以预处理出来。因此建虚树，**计算一个点和它父亲间作用点的分界点** 即可。
2. 实现上可以不用真的建虚树，同时把lca也当做关键点预处理dis，因为只会新增O(1)个点，因此复杂度仍然是log^2.

### jzoj7135

0. 有n个数hi，每次可以区间加，或者区间变成形如ax^2  + bx+c的形式，求最大的x使得hi%x==同一个数r. n<=1e5.
1. 注意到相邻的数一减，余数就没了，然后就求gcd。区间加很好做。区间变化可以发现结论是区间gcd会变成gcd(kl+m , k),也可以再差分一次，变成gcd(2a, b+a)的整体赋值。

### jzoj7136

0. 要用1~24按某个排列填进数列里，使得这个数列时时刻刻的每个区间都至少有一个独一无二的数。n<=8500.
1. 题解的精妙方法：分3个一组，每次提出组内最早的那个变成子问题，然后发现间隔最多是4，那就填跟相邻两个不同的。
   因为任何时候，要不就是空格增加，要不就是空格断裂重来（减少了），因此一定可以构造。
2. LS的好方法：考虑pi==i怎么做：填lowbit(就是每次删掉奇数位)。然后！到一般情况，倒着填，每次填完就删掉相邻两个还存在，没填的位置。
   由于相邻的还没填，到时候一定会断开。由于至少让n变成了2/3倍，因此是log1.5 n 的！
   因此还是要考虑部分分。



### jzoj7137⼈赢的情书

0. 有一种字符串，字符集是1~m，找出一种生成方法使得：1.长度为n； 2.第i大的是后缀pi； 3.$\sum |si - vi]$ 最小。
1. 转化题意：一个后缀可以由二元组(char, rk[pi+1])来比较：于是我们就得到这样一个问题:最小化$\sum |xi-vi|, x_i>=x_{i-1}+bz_i, bz\in [0,1]$ .
2. 经典保序回归L1,求出区间中位数后单调栈即可，然鹅官方的保序回归是整体二分。由于主席树版土味保序回归太慢了只有60……。
3. 不用保序回归，观察dp的f i,j数组，会发现是个只有左边凸，右边平的函数，每次加上一个V字形。用个set or heap维护二重差分标记：在最小值右边的话就更新最小值位置，否则消去第一个1，在极值点加入+2.（补上常数）。
4. 这题观察还是不够仔细：没有发现f是左凸右平的，只是想着要从下面转移，没有进一步分析单调点的灵感。

### jzoj6249七星连珠

0. 有个50*50的矩阵，每个位置有一个数<k^7，求取一个排列，乘积的所有可能值。其中乘法被定义为k进制下不进位加法。k=2 or 3.
1. 考虑行列式； 考虑怎么搞这个异或。 乘法显然不能变化（因为求出的只有sigma)，那么，==考虑把值放到次数上做循环卷积！== **多项式高消考虑能否点值**：先构造一种Dft使得它能循环，那么接下来就是算每个位置的点积。
2. Dft： 见《FWT ？ FFT ！》； 认识不够深刻！

### jzoj7139重建计划 提答

0. 求一些点的最小斯坦纳树。有加了一些边的点，也有貌似dp的点，有一般图和网格图。
1. 做法1：最小斯坦纳树模板，同集合spfa转移。
2. 做法2：暴力两两最短路再最小生成树，判重；
3. **做法3**：随机加入顺序,在当前已经联通的点中扒出一条到当前关键点的最短路！。



### IOI2021 分糖果

0. 当前有2e5个盒子，初始有0颗糖，有2e5次询问，可以放糖或取糖，对ci取min，对0取max。求最后的值。
1. **考虑把min和max操作放到增加前边** ： 由于这个**加减后min max不好做**，那么：假设选定了一个位置，假定fi是i时刻它不取minmax的权值，考虑把它拉到这个区间里：[min(ci-fi), max(-fi)].那么当一个些区间并为空，那么它就自动变成上下边界，否则就真的拿0去跟区间对线。
2. **拉出修改** ： 使用线段树分治（就是维护动态联通性那个），或者直接扫描线。

### IOI2021 钥匙

0. 每个点有一个某种类型的钥匙； 每条边要某种类型的钥匙；拿到一个钥匙之后永远拥有。求联通块大小**等于最小值**的那些点。
1. 经过转化可以发现是找出**叶子边双**。怎么找呢？
2. 不应该考虑直接整个DAG；实际上应该随便从一个点开始，==像tarjan那样==用栈找,找到叶子之后挂一下颜色，之后如果行，就线段树合并上来。

### IOI2021 公园

0. 偶点上有喷泉，相邻偶点间可连边，奇点上可放长椅，每条边必须要被一个长椅匹配，要保证联通时得到方案。
1. 算法1:0/1/2/3方向顺序标号染色： hack:挂边。
2. 算法2：0/1/2/3四色贪心染色：hack：会连到一起。
3. 算法3：简单又自然的方法：黑白染色，横边跟黑格子，竖白，冲突了就删掉上边/左边那条。

### jzoj7147 模板题

0. 求只有奇数条边组成的无向联通图的个数，点有序，n<=1e6.
1. **把边带上-1的边权再算一次！**(果然是“模板题”)注意后面那个Ln可以手算。

### powerful number习题

1. jzoj7153 function
   求积性函数前缀和，其中$f(p^k) = p^m, m=2 \ or\  3$ ,9e12.
   使用狄利克雷生成函数，以2为例设
   $$
   F=\prod_p (1+p^2*(p^{-x}+p^{-2x}+...))\\
   =\prod_p (\frac{1-p^{-x}+p^{2-x}}{1-p^{-x}})  \\
   $$
   猜一下：我们要搞出两个能卷的函数来powerful number,考虑到G(x)=x^m这个积性函数跟它长得很像，那么强行塞一个:
   $$
   =\prod_p (\frac{1-p^{-x}+p^{2-x}}{1-p^{-2x}} \ * \ \frac{1-p^{-2x}}{1-p^{-x}}) \\
   =[\frac{1}{n^x}]\ (\sum_n n^2) * (\prod_p (1+(p^m - p^{2m})*(...)))
   $$
   那么就知道两个积性函数分别是啥了。



### jzoj7151 tennis

0. 多次询问，求$\sum 2^{i-1}i(C(n+m-i, n)+C(n+m-i,m))$ .qn<=3e5,n,m<=2e5. 5s
1. **考虑根号做法：既然无法分块，那就想想莫队** 。莫队可以维护组合数，同样经过化简这个式子也能维护。但是常数较大。
2. **数形结合** ： 在**杨辉三角上**推导这个式子（带上系数），可以推出最终的纯组合数式；或者推不了时组合意义。最后四次组合数询问可以变1次。

### jzoj7150 自动化leetcode

0. 对于数列里的每个数ai，数v跟它对线一下会变成$|ai-v|$ ,多次询问没有修改，求v从l走到r会变成什么。ai<=1e7, n,q<=1e5.
1. 因为单个数难以维护，部分分又提示我们要分块，考虑处理每个数的答案是什么？（倒过来）。
   No：直接从前往后**对所有数一起**考虑，一个abs会翻转一些数使得它以后的命运和别的数相同，**总势能是O(V)的**。那么取块大小为sqrt(V)即可。

### jzoj6058 false-false-true

0. 有n+m道题，n道答案为true，m为false，每次按最优策略猜一个答案，会告诉你对不对，求期望最小错误数。
1. 首先为了简单变成最大答对数。考虑到：假定当前有n>m,肯定先一直猜n（因为至少有n），即答案会是max(n,m).然后n=m的时候一定可以多对0.5道。因此直接算一下平面走点方案数即可。
2. or：神妙的化柿子：$f(i,j)=max(i,j)/(i+j) + i/(i+j) * f(i-1,j)+j/(i+j)*f(i,j-1)$. 设$g(i,j)=f(i,j)-max(i,j)$,那么可以化为$g(i,j)=i/(i+j)*g(i-1,j) + j*(i+j)*g(i,j-1)$. 然后注意到i==j时又有一个多余的1/2贡献，那么同理。



### jzoj6057 小凯的疑惑

0. 有一些点，点权为0~2^14 -1，完全图，边权为vi xor vj.求把v整体加上一个数（模2^14）意义下的值。
1. **想到了按128分开处理，但是没有进一步优化，从而没有利用好块。** 题解相当于把2^7次方的**这个块缩成一个点**，预处理**点与点间**的权值，再用字典树的方法查询。处理的时候**再对最下面3层**特殊处理（因为形态只有2 ^ 8种）。
2. wmy的神奇方法：注意到询问的时候要重新处理log层区间，可以把区间表示成(s,len)预处理好。预处理时直接递归整个trie（因为满的trie节点数没有log！）

  

### jzoj7159 是谁

0. 求一个长度为3e5的二进制数角谷猜想要几次。随机。
1. 考场上没有过多搞这题。经打表，总操作次数在nlog左右，把除以2的缩起来就是O(n)次。把操作压位就除以了一个w。
2. 还不够：**考虑把操作也缩起来**。对一个unt,先处理完这个数，再把若干个乘三和进位往上爬，又除以了w。位移移动指针即可。
   因此要考虑还有什么能缩 or 怎么加速，因为这种题非常像乱搞题。

### jzoj6136 max

0. 构造一个长度为2n-1的序列的偶数位，其中每个数绝对值都要<=K,使得（正确的最大子段和）-（只取段里全>=0的最大子段和）最大。n<=5000,K<=100000.
1. 和题解不同的地方主要在于我考虑了错误的答案，dp正确的答案；题解考虑正确的，而dp错误的。考虑错答后发现答案序列并没有很好的性质，而且K不能作为复杂度中>=1次的项。实际上应该**按照sub1的提示（n<=20), 猜**一下只选-1 or K的结论，接下来就好多了。
2. 题解进一步推导到正确区间一定是[1,n]（假定首尾都是非负）。设f(i,j)表示j个-1，接下来优化dp即可。
3. LS发现一个奇怪的结论：平均上讲，答案会落在$\sqrt{2n}$左右……所以dp100个就能过了……



### jzoj6088 白

0. 一次旅行的贡献是(s & t),求若干次旅行贡献and起来<=n，<=m步的异或和。n<64, m<=20000.
1. 预处理：注意到常系数齐次线性递推求出的**是一个长度为n的递推式**，既可以用来快速矩乘，==也可以缩短递推式==。因此先用行向量乘上当前位置前n项矩阵，后即可做到O(n)得到当前答案。而**直接计算FWT后的结果**（即：s&y=y, t&y=y)又可以省一个n。实际上**是容斥**。
2. 二维数组，第二维不可循环，那么将第一维**变成点值**，即可对应相乘。多项式求逆即可。
3. 容斥直接计算十分巧妙。要注意到iFWT本质就是容斥。点值可以相乘而循环卷积。也可以BM代替快速矩乘，sqrt(M)O(1)计算等。

### jzoj100207 决心

0. 有个长度为n的排列A，有一些位置不见了，需要枚举。一次操作指：进行若干次交换两个位置，一个位置不能在一次操作中出现两次，问在操作最少情况下方案总数和。
1. 首先发现操作次数<=2.接着发现环方案数是n，以及能把两个环拼起来。
2. 解决排列问题：发现是若干链，**直接分配到集合中**(环长不变)，方案数即为B(12).

### jzoj7167简单的希尔伯特曲线题

0. 有一个点，每次变换一次：即把它按两条对角线翻转放到下面，原封不动放上面两份，求做n<=64次后某矩形的和。
1. 根据部分分一步一步推，得到一行的和是$2^{n-1}(4^n-1)$.那么这样对分治讨论，复杂度就对了！

### jzoj7168简单的字符串题

0. 求选出两个相同子串，位置区间的交的长度的概率。
1. 瞎转化成了后缀树上的log^2,结果真有人过……
2. 应该换个方向考虑； 或者**把多余的部分删掉，注意相交这个条件**，发现他们还是相等，即我们重复计算了一些东西。那么前面只剩下AA串，数它的贡献即可。分母可用单调栈。

### jzoj7169简单的bzoj题

0. 动态询问一个区间恰好取k个数，相邻不能取，答案最大值。
1. 显然凸包闵科夫斯基和。实现技巧是vector.resize和二分是只需要比较A[i]和A[i-1]+mid.
2. 凸优化的斜率范围：最大的那个斜率。一般可以直接取什么max(ai) * n之类。这题是一定要，因为可能有"-5e4,5e4,-5e4,5e4,-5e4",然后2变3.

### jzoj7170game

0. 有一种游戏：在一棵树根放若干棋子，每次只能移动一个，不能移动者输。操作是每次会复制一棵树或者新建一棵树。树上的叶子有50%的概率长一个儿子出来。求必胜态个数。N<=1e6.
1. 首先ci为奇才参与SG值XOR。考虑找出SG。**一棵树SG值<=logn!**.**其实只要再玩多一会就能搞出来了**。那么即可状压。
2. 进一步：**对S从小到大加**，粗略观察得到Sg=k只有n/(2^k)个左右，因此复杂度正确。最后暴力卷积。

### jzoj7171del

1. 要注意到**树上联通块删除一条边，相当于扒掉一个子树**。

### jzoj7172mex

介绍了动态修改区间mex真的能做：

1. 只能一次bst,因此处理块间。
2. 取B=n^(2/3), 因此得到算法：$\frac{n^2}{64} + n^{5/3}$

