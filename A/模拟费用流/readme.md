# 模拟费用流！

[toc]



## 费用流要素

大部分问题都是求解：最小费用任意流。

核心在于：**A.负增广路 B.负环**
其中负环可以通过跟它相交的已知增广路转化为A.负增广路。

因此在一般性分析时，应对于**增量**考虑，只需要找出图中**新增的A和B**。
进而根据其**含义**分析决策。但实际上可能不实用，因此可以直接套类型。

当有流量限制时，可以简单地通过凸优化转化为任意流。



## 模拟方法

### 1.真的模拟增广路

即：提取出每次增广长啥样，要干啥，用DS去快速维护。



##### [本无不散之宴](https://gmoj.net/senior/#main/show/5152)

一种方法是理解整个过程，用线段树维护最紧那个，其实貌似跟增广路没多大关系。

一种方法是建点：设每个区间前端（不跟后面相交的部分）为自己的牌堆，进行建点，然后模拟，这才是真模拟。

##### [PA2013Raper](https://www.luogu.com.cn/problem/P4694)

同样有线段树做法。维护：$f_i=premin(a_i)+sufmin(b_i)$

当ai和bi发生变化的时候可以重新维护当前区间的单调栈，暴力取出对应的nxt_min进行区间赋值。每个点只会被拎出来一次。





### 2.“凸性”：三分流量 or Slope Trick维护dp

##### [ C（c）](https://gmoj.net/senior/#contest/show/3633/2) 

类似的题还有：Codeforces 1534G

0. 有一个环上的n堆石子，每堆ai，要求左右移动后（设为bi）使得满足Li<=bi<=Ri.最小化移动石子个数。n,a,L,R<=3.5e4. 典型的费用流问题。

1. **将流量设进状态**。设Xi为第i堆向右移动了几个(可负)。首先枚举X1断环。
   设$f[i][j]$ 表示第1~i堆满足条件同时Xi=j，即流量为j。
   显然，它**仍然是类似于原费用流问题的凸性玩意**，其实也就是子费用流啦。

   转移很简单：$f[i-1][k]->f[i][j] :L_i<=a_i+k-j<=R_i $ 

2. 考虑优化这玩意。
   利用X1也是凸的，先三分掉X1。

   $f$的第二维是凸的，此时就使用**SlopeTrick**维护$f$。
   一次转移总结如下：
   a.进行L'的位移。
   b.在凸包斜率为负的半边平移R'-L'个单位
   c.加上一条y=|x|的折线。

##### Slope Trick的实现

1. 使用两个堆（类似对顶堆）分别维护斜率<0和>0的线段。=0的处理是忽略。
2. 维护一个变量val代表凸包最低点的纵坐标。
3. 这个凸包钦定是这样：图像连续，**每经过一个单点，斜率增大1**.
   因此2=c操作即<u>“加入两个零点”</u>。
   并直接截开跨过中间的线段。
4. 算答案的时候注意左边val要-=。





### 3.费用流本质|特殊图

核心：

#### 关键点类

形式上，有很多别的点构成某几个关键点的最短路组成。

必须对所有关键点、源汇点之间的==**所有增广方式**==进行最短路的统计。
如Coins一题，必须统计F1->F2这样的方式。
（不用统计什么F1->F2->F1之类的，因为此前必然最优化）

#### 链类

形式上，注意到，无论是单向还是双向链，都可以转化为**中间一条**，旁边两连的形式。上树后，在lca处统计本质上还是链状。

链具有交换性。当交叉匹配时可以简单视作**交换**了点。因此不需像上面考虑各种迂回。

==**此时只有一个核心操作：将A堆与B堆的top匹配**==。

==**此时只需保证：匹配完后各向对方提供一反悔点**==。

直接做复杂度是O(sum 点数)级别。将相同点缩起来就是O(链长)级别。



**单向链：**

##### [PA2013Raper](https://www.luogu.com.cn/problem/P4694)

![](https://cdn.luogu.com.cn/upload/image_hosting/3o3amb67.png)

如YYC图。下文引自YYC。

如图 I ，红色边为新加入的边（方向确定），黑色边为旧的边，方向是不确定的（可能由于增广而反向）

- 源汇路径 ： 必然经过 S 惟一的红出边，所有 T 的入边都是可选的。这对应选择一个最小的未被匹配的 b 进行匹配。如图 II 。

- 负环 ： 经过讨论，图中可能的新环只有形如图 III,IV 的两种形式。

  对于形式 III ，对应以目前的 a 替换掉之前的一个比较大的 a。

  对于形式 IV ，实际上永远不优。其可以拆分成一条 S→T 和一条 T→S。由于所有 T→S 的权值必定小于 0 （否则当初不会选取），故该方案不如单走一个 S→T。

  然而，在有流量限制的原问题中，单走一个 S→T 可能不合法，使得我们的证明失效。这也是为什么我们要用 WQS 二分去掉 k 的限制。

上述合法的两种决策容易用堆维护（注意还需维护匹配个数），故复杂度为 O(*n*log2n)。

##### [CF730I Olympiad in Programming and Sports](https://www.luogu.com.cn/problem/CF730I) 整体与分层

通过新增的边分析路径。

1.**同一决策的权值要完整**，不能拆开两步考虑，即同一增广路（负环）的权值不能拆开分析。

2.考虑一条增广路是否会递归：如b踩了a，a换了之后又踩了c。从图上或意义上考虑，这样早就会增广。因此不会多层，只有一层。



##### BZOJ4877 [Lydsy1708月赛]跳伞求生

本题可以分析出三种增广方式，只有两种有效。

根据增广路：1.代掉某点，换一条边； 2.直接换边； 3.S上有负环

其中1不可能更优，否则早就被增广了。因此对应出的含义是：1.直接匹配；2.换掉一个坏玩家。



**双向链：**

[#455. 【UER #8】雪灾与外卖](https://uoj.ac/problem/455) 

![](https://cdn.luogu.com.cn/upload/image_hosting/opakfkrt.png)





也可以直接用一个简单的**线段树**维护。具体的：

往右走：dis即为len之和。
往左走：有些dis为yi,有些为-xi。因为负权边加来加去只会从负变成正至多一次，因此线段树单点修改即可。



##### 「ICPC World Finals 2018」征服世界

树上双向链。将老鼠拼上-inf的权值，那么相当于强制匹配了。

考虑维护两个堆进行匹配。那么新的代价就是强行补上当前玩意的代价：

new vx=2*dep[lca] -vy等。

这样强行匹配，由于反悔次数不会太多，因此正确。

那么可以知道正常的应该也差不多。

这里：pbds里的优先队列可以join！



做到这里，可以发现通过设置-inf和反悔点等方式，老鼠不再是老鼠，洞也不在是洞，它们只是两种权值罢了！(bushi)



4.线性规划对偶等化成dp等技巧
