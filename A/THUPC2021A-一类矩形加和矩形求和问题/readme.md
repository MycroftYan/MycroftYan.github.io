# 题意：

询问一个区间内的本质不同逆序对个数。n<=1e5,m<=5e5,ai<=n;

一对逆序对相同 被定义为有序数对(x,y) == (u,v).

THX LXL。本文基于对他的题解的理解写成。



# 题解

**转化：**

1.莫队。假设r指针往右移动了一位，r' 为前一个与r颜色相同的点，即查询这样的x的个数：
$x\in (r'+1,r-1), \notin (l,r'), 且a_x>a_r$.
（l移动了可以反过来做）

2.将n^1.5个询问二次离线。接下来：可以扫描线一下：将l指针从n到1递减，维护一个数集，里面存的是某种颜色（同种权值）的那群点中，离当前l指针最近的那个点，形式是(i,ai).

3.将询问差分成：在l端点，加上r查询的结果，减去r’查询的结果（因为要是一个权值在(l,r')也出现了就会被再次查到，然后减掉。）
查询的是：当前x坐标小于等于qx的点中，y坐标大于qy的点的个数。



问题转化为：**O(n)次单点修改，O(n^1.5)次矩形查询。**

**维护：**

用一个神奇的结构维护：取块大小B=n ^ 0.75,（即有n ^ 0.25个块）， 那么x轴会往下递归4层（取sqrt(n)是两层，类比一下），同样的，y轴也会递归4层。

理论上，添加一个点时，我们要在第一层爬那些大块(n ^ 0.75)，然后整体打上标记，接下来到了自己的大块，再爬中等大小的块(n ^ 0.75 / n ^ (0.25)) ，再……这样爬一次的复杂度是n ^ 0.25的。

但是有两维，如果两维都这样爬，虽然时间是n ^ 0.25 * n ^ 0.25 = n ^ 0.5,但是空间是n ^ 2的：怎么办呢？

规定剩下两维（对于第三第四层网格）不爬（因为这个时候值域只剩下n ^ 0.5了），直接加。我们没爬的x坐标还剩sqrt(n)个，因为实际上我们的询问也是(i,ai)的形式，那么我们就给这sqrt(n)个询问更新一下。同样的y也这样暴力更新一下，只不过y可能有重，所以要离散一下。

核心代码（版权声明：lxl）

```cpp
void inc(int x,int sgn){
	int y=ys[x];
	int x2=bs[x].x2,x3=bs[x].x3;
	int y2=bs[x].y2,y3=bs[x].y3;
	#define Fi3 F(i,0,x3)
	#define Fi2 F(i,x3*B,x2)
	#define Fj3 F(j,0,y3)
	#define Fj2 F(j,y3*B,y2)
	Fi3 Fj3 s33[i][j]+=sgn;
	Fi2 Fj2 s22[i][j]+=sgn;
	Fi2 Fj3 s23[i][j]+=sgn;
	Fi3 Fj2 s32[i][j]+=sgn;
	F(i,x2*B2,x)if(ys[i]<y2*B2)sx[i]+=sgn;
	F(j,y2*B2,y)if(ps[j].x<x)sx[ps[j].x]+=sgn;
}
```




# 可拓展性

#### 其他的二维普通情况：

对于更为普通二维矩形加和矩形求和，同样可以离散之后变成$O(sqrt(n))-O(1)$的。（然鹅n ^ 1.5个询问怎么离散？可能需要根据题目特性用个桶之类的。）

而对于这种网格加，网格求和（即不是有n个在平面上的点，而是对网格加和）的问题，可以用类似于树状数组区间修改区间求和的差分方式套个线段树（或树状数组动态开点），做到$O(\log^2(n)) - O(\log^2(n))$ .

#### 区间逆序对（不用本质不同）

然鹅经过探索，发现上面那段话的方法并不适用于这个。同样是矩形加，对象却变成了n个二维的点。这样会导致线段树下传的系数不确定，从而导致标记不可合并。

因此还是只有kdt or LL分块可以解决这个问题。

#### 更高维度和别的块大小：

同样的，对于三维，同样取块数等于n ^ (1/4),  同样可以做到$O(sqrt(n))-O(1)$,然鹅空间变成了n ^ 1.5.

为什么二维不取块数为 n ^ (1/6) 呢？
我认为，主要原因是复杂度两边并不平衡。同时，修改复杂度减小也会导致空间复杂度和常数增大。

二维时，当块数取n ^ (1/k) 时，可以做到O(n ^ (1/k))修改的复杂度，然鹅空间是O(n ^ (2k-2)/k)的。x维即n ^ (kx-k)/k.

然鹅更高维需要平衡达到更优空间。



由于作者能力有限，如有谬误，敬请致信2546240576@qq.com.



YYT & ZFY.

2021.6.20.
